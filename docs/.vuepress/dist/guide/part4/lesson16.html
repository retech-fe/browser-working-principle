<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Webapi：setTimeout是怎么实现的 | 浏览器工作原理与实践</title>
    <meta name="generator" content="VuePress 1.9.8">
    <link rel="icon" href="/browser-working-principle/logo.png">
    <link rel="manifest" href="/browser-working-principle/manifest.json">
    <link rel="apple-touch-icon" href="/browser-working-principle/icons/apple-touch-icon-152x152.png">
    <link rel="mask-icon" href="/browser-working-principle/icons/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="极客浏览器工作原理与实践">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="msapplication-TileImage" content="/icons/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/browser-working-principle/assets/css/0.styles.f75e23f6.css" as="style"><link rel="preload" href="/browser-working-principle/assets/js/app.f3d4122f.js" as="script"><link rel="preload" href="/browser-working-principle/assets/js/3.a46f6e33.js" as="script"><link rel="preload" href="/browser-working-principle/assets/js/31.029dd5e9.js" as="script"><link rel="preload" href="/browser-working-principle/assets/js/6.7e6898f0.js" as="script"><link rel="prefetch" href="/browser-working-principle/assets/js/10.979ea408.js"><link rel="prefetch" href="/browser-working-principle/assets/js/11.0eed5283.js"><link rel="prefetch" href="/browser-working-principle/assets/js/12.6053964d.js"><link rel="prefetch" href="/browser-working-principle/assets/js/13.20ba34ea.js"><link rel="prefetch" href="/browser-working-principle/assets/js/14.535ca783.js"><link rel="prefetch" href="/browser-working-principle/assets/js/15.af1f3066.js"><link rel="prefetch" href="/browser-working-principle/assets/js/16.f1595b3a.js"><link rel="prefetch" href="/browser-working-principle/assets/js/17.928ebb06.js"><link rel="prefetch" href="/browser-working-principle/assets/js/18.90df7ee0.js"><link rel="prefetch" href="/browser-working-principle/assets/js/19.38670ea4.js"><link rel="prefetch" href="/browser-working-principle/assets/js/20.d236e815.js"><link rel="prefetch" href="/browser-working-principle/assets/js/21.48ec90b3.js"><link rel="prefetch" href="/browser-working-principle/assets/js/22.b48cab7d.js"><link rel="prefetch" href="/browser-working-principle/assets/js/23.5833d70e.js"><link rel="prefetch" href="/browser-working-principle/assets/js/24.5eaf91ce.js"><link rel="prefetch" href="/browser-working-principle/assets/js/25.69024d3a.js"><link rel="prefetch" href="/browser-working-principle/assets/js/26.ed3382f0.js"><link rel="prefetch" href="/browser-working-principle/assets/js/27.e3dc9469.js"><link rel="prefetch" href="/browser-working-principle/assets/js/28.f0aecf87.js"><link rel="prefetch" href="/browser-working-principle/assets/js/29.6db3d906.js"><link rel="prefetch" href="/browser-working-principle/assets/js/30.1f9b6521.js"><link rel="prefetch" href="/browser-working-principle/assets/js/32.d7264412.js"><link rel="prefetch" href="/browser-working-principle/assets/js/33.a26d71b6.js"><link rel="prefetch" href="/browser-working-principle/assets/js/34.66136bd3.js"><link rel="prefetch" href="/browser-working-principle/assets/js/35.a70e870d.js"><link rel="prefetch" href="/browser-working-principle/assets/js/36.94f8a907.js"><link rel="prefetch" href="/browser-working-principle/assets/js/37.1ea607ef.js"><link rel="prefetch" href="/browser-working-principle/assets/js/38.558ac1bc.js"><link rel="prefetch" href="/browser-working-principle/assets/js/39.cfed7b7d.js"><link rel="prefetch" href="/browser-working-principle/assets/js/4.44d60c7a.js"><link rel="prefetch" href="/browser-working-principle/assets/js/40.bfaa20b5.js"><link rel="prefetch" href="/browser-working-principle/assets/js/41.4abc37d8.js"><link rel="prefetch" href="/browser-working-principle/assets/js/42.aaf1271f.js"><link rel="prefetch" href="/browser-working-principle/assets/js/43.8fff24cc.js"><link rel="prefetch" href="/browser-working-principle/assets/js/44.97c8d4dc.js"><link rel="prefetch" href="/browser-working-principle/assets/js/45.b6065bc3.js"><link rel="prefetch" href="/browser-working-principle/assets/js/46.9851780f.js"><link rel="prefetch" href="/browser-working-principle/assets/js/47.e728aa43.js"><link rel="prefetch" href="/browser-working-principle/assets/js/48.50c2ee75.js"><link rel="prefetch" href="/browser-working-principle/assets/js/49.7d5de0f8.js"><link rel="prefetch" href="/browser-working-principle/assets/js/5.83db2897.js"><link rel="prefetch" href="/browser-working-principle/assets/js/50.e75df357.js"><link rel="prefetch" href="/browser-working-principle/assets/js/51.7b61b896.js"><link rel="prefetch" href="/browser-working-principle/assets/js/52.1789fc09.js"><link rel="prefetch" href="/browser-working-principle/assets/js/7.87e6c11e.js"><link rel="prefetch" href="/browser-working-principle/assets/js/8.fb0ddc6c.js"><link rel="prefetch" href="/browser-working-principle/assets/js/9.ded9c2fb.js"><link rel="prefetch" href="/browser-working-principle/assets/js/vendors~notification.66175131.js">
    <link rel="stylesheet" href="/browser-working-principle/assets/css/0.styles.f75e23f6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container custom-code-highlight"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/browser-working-principle/" class="home-link router-link-active"><!----> <span class="site-name">浏览器工作原理与实践</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/browser-working-principle/guide/" class="nav-link router-link-active">
  指南
</a></div> <a href="https://github.com/retech-fe/browser-working-principle" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/browser-working-principle/guide/" class="nav-link router-link-active">
  指南
</a></div> <a href="https://github.com/retech-fe/browser-working-principle" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>宏观视角上的浏览器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part1/lesson01.html" class="sidebar-link">Chrome架构：仅仅打开了1个页面，为什么有4个进程</a></li><li><a href="/browser-working-principle/guide/part1/lesson02.html" class="sidebar-link">TCP协议：如何保证页面文件能被完整送达浏览器</a></li><li><a href="/browser-working-principle/guide/part1/lesson03.html" class="sidebar-link">HTTP请求流程：为什么很多站点第二次打开速度会很快</a></li><li><a href="/browser-working-principle/guide/part1/lesson04.html" class="sidebar-link">导航流程：从输入URL到页面展示这中间发生了什么</a></li><li><a href="/browser-working-principle/guide/part1/lesson05.html" class="sidebar-link">渲染流程（上）：HTML、CSS和JavaScript是如何变成页面的</a></li><li><a href="/browser-working-principle/guide/part1/lesson06.html" class="sidebar-link">渲染流程（下）：HTML、CSS和JavaScript是如何变成页面的</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器中的JavaScript执行机制</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part2/lesson07.html" class="sidebar-link">变量提升：JavaScript代码是按顺序执行的吗</a></li><li><a href="/browser-working-principle/guide/part2/lesson08.html" class="sidebar-link">调用栈：为什么JavaScript代码会出现栈溢出</a></li><li><a href="/browser-working-principle/guide/part2/lesson09.html" class="sidebar-link">块级作用域：var缺陷以及为什么要引入let和const</a></li><li><a href="/browser-working-principle/guide/part2/lesson10.html" class="sidebar-link">作用域链和闭包：代码中出现相同的变量，JavaScript引擎如何选择</a></li><li><a href="/browser-working-principle/guide/part2/lesson11.html" class="sidebar-link">this：从JavaScript执行上下文视角讲this</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>V8工作原理</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part3/lesson12.html" class="sidebar-link">栈空间和堆空间：数据是如何存储的</a></li><li><a href="/browser-working-principle/guide/part3/lesson13.html" class="sidebar-link">垃圾回收：垃圾数据如何自动回收</a></li><li><a href="/browser-working-principle/guide/part3/lesson14.html" class="sidebar-link">编译器和解析器：V8如何执行一段JavaScript代码的</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>浏览器中的页面循环系统</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part4/lesson15.html" class="sidebar-link">消息队列和事件循环：页面是怎么活起来的</a></li><li><a href="/browser-working-principle/guide/part4/lesson16.html" aria-current="page" class="active sidebar-link">Webapi：setTimeout是怎么实现的</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/browser-working-principle/guide/part4/lesson16.html#浏览器怎么实现-settimeout" class="sidebar-link">浏览器怎么实现 setTimeout</a></li><li class="sidebar-sub-header"><a href="/browser-working-principle/guide/part4/lesson16.html#使用-settimeout-的一些注意事项" class="sidebar-link">使用 setTimeout 的一些注意事项</a></li><li class="sidebar-sub-header"><a href="/browser-working-principle/guide/part4/lesson16.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/browser-working-principle/guide/part4/lesson17.html" class="sidebar-link">Webapi：XMLHttpRequest是怎么实现的</a></li><li><a href="/browser-working-principle/guide/part4/lesson18.html" class="sidebar-link">宏任务和微任务：不是所有的任务都是一个待遇</a></li><li><a href="/browser-working-principle/guide/part4/lesson19.html" class="sidebar-link">使用Promise告别回调函数</a></li><li><a href="/browser-working-principle/guide/part4/lesson20.html" class="sidebar-link">async await使用同步方式写异步代码</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器中的页面</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part5/lesson21.html" class="sidebar-link">页面性能分析：利用chrome做web性能分析</a></li><li><a href="/browser-working-principle/guide/part5/lesson22.html" class="sidebar-link">DOM树：JavaScript是如何影响DOM树构建的</a></li><li><a href="/browser-working-principle/guide/part5/lesson23.html" class="sidebar-link">渲染流水线：CSS如何影响首次加载时的白屏时间？</a></li><li><a href="/browser-working-principle/guide/part5/lesson24.html" class="sidebar-link">分层和合成机制：为什么css动画比JavaScript高效</a></li><li><a href="/browser-working-principle/guide/part5/lesson25.html" class="sidebar-link">页面性能：如何系统优化页面</a></li><li><a href="/browser-working-principle/guide/part5/lesson26.html" class="sidebar-link">虚拟DOM：虚拟DOM和实际DOM有何不同</a></li><li><a href="/browser-working-principle/guide/part5/lesson27.html" class="sidebar-link">PWA：解决了web应用哪些问题</a></li><li><a href="/browser-working-principle/guide/part5/lesson28.html" class="sidebar-link">webComponent：像搭积木一样构建web应用</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>浏览器中的网络</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/browser-working-principle/guide/part6/lesson29.html" class="sidebar-link">HTTP1：HTTP性能优化</a></li><li><a href="/browser-working-principle/guide/part6/lesson30.html" class="sidebar-link">HTTP2：如何提升网络速度</a></li><li><a href="/browser-working-principle/guide/part6/lesson31.html" class="sidebar-link">HTTP3：甩掉TCP、TCL包袱 构建高效网络</a></li><li><a href="/browser-working-principle/guide/part6/lesson32.html" class="sidebar-link">同源策略：为什么XMLHttpRequst不能跨域请求资源</a></li><li><a href="/browser-working-principle/guide/part6/lesson33.html" class="sidebar-link">跨站脚本攻击XSS：为什么cookie中有httpOnly属性</a></li><li><a href="/browser-working-principle/guide/part6/lesson34.html" class="sidebar-link">CSRF攻击：陌生链接不要随便点</a></li><li><a href="/browser-working-principle/guide/part6/lesson35.html" class="sidebar-link">沙盒：页面和系统之间的隔离墙</a></li><li><a href="/browser-working-principle/guide/part6/lesson36.html" class="sidebar-link">HTTPS：让数据传输更安全</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="webapi-settimeout是怎么实现的"><a href="#webapi-settimeout是怎么实现的" class="header-anchor">#</a> Webapi：setTimeout是怎么实现的</h1> <p>那在接下来的两篇文章中，我会通过setTimeout和XMLHttpRequest这两个 WebAPI 来介绍事件循环的应用。这两个 WebAPI 是两种不同类型的应用，比较典型，并且在 JavaScript 中的使用频率非常高。你可能觉得它们太简单、太基础，但有时候恰恰是基础简单的东西才最重要，了解它们是如何工作的会有助于你写出更加高效的前端代码。</p> <p>本篇文章主要介绍的是setTimeout。其实说起 setTimeout 方法，从事开发的同学想必都不会陌生，它就是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。下面的示例代码就演示了定时器最基础的使用方式：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 极客时间 &quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>执行上述代码，输出的结果也很明显，通过 setTimeout 指定在 200 毫秒之后调用 showName 函数，并输出“极客时间”四个字。</p> <p>简单了解了 setTimeout 的使用方法后，那接下来我们就来看看浏览器是如何实现定时器的，然后再介绍下定时器在使用过程中的一些注意事项</p> <h2 id="浏览器怎么实现-settimeout"><a href="#浏览器怎么实现-settimeout" class="header-anchor">#</a> 浏览器怎么实现 setTimeout</h2> <p>要了解定时器的工作原理，就得先来回顾下之前讲的事件循环系统，我们知道渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。下面我们来看看那些典型的事件</p> <ul><li>当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中，</li> <li>当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。</li> <li>当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。</li> <li>同样，如果要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中</li></ul> <p>以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。</p> <p>所以说要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。</p> <p>那么该怎么设计才能让定时器设置的回调事件在规定时间内被执行呢？你也可以思考下，如果让你在消息循环系统的基础之上加上定时器的功能，你会如何设计？</p> <p>在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，渲染进程会将该定时器的回调任务添加到延迟队列中</p> <p>源码中延迟执行队列的定义如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>DelayedIncomingQueue delayed_incoming_queue;
</code></pre></div><p>当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>struct DelayTask{
  int64 id；
  CallBackFunction cbf;
  int start_time;
  int delay_time;
};
DelayTask timerTask;
timerTask.cbf = showName;
timerTask.start_time = getCurrentTime(); // 获取当前时间
timerTask.delay_time = 200;// 设置延迟执行时间
</code></pre></div><p>创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>delayed_incoming_queue.push(timerTask)；
</code></pre></div><p>现在通过定时器发起的任务就被保存到延迟队列中了，那接下来我们再来看看消息循环系统是怎么触发延迟队列的。</p> <p>我们可以来完善上一篇文章中消息循环的代码，在其中加入执行延迟队列的代码，如下所示</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">ProcessTimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token comment">// 从 delayed_incoming_queue 中取出已经到期的定时器任务</span>
  <span class="token comment">// 依次执行这些任务</span>
<span class="token punctuation">}</span>
 
TaskQueue task_queue；
<span class="token keyword">void</span> <span class="token function">ProcessTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bool keep_running <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">MainTherad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 执行消息队列中的任务</span>
    Task task <span class="token operator">=</span> task_queue<span class="token punctuation">.</span><span class="token function">takeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ProcessTask</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 执行延迟队列中的任务</span>
    <span class="token function">ProcessDelayTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
 
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>keep_running<span class="token punctuation">)</span> <span class="token comment">// 如果设置了退出标志，那么直接退出线程循环</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面代码可以看出来，我们添加了一个ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。这里我们要重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。</p> <p>设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用clearTimeout 函数，并传入需要取消的定时器的 ID。如下面代码所示：</p> <div class="language- extra-class"><pre class="language-text"><code>clearTimeout(timer_id)
</code></pre></div><p>其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。</p> <h2 id="使用-settimeout-的一些注意事项"><a href="#使用-settimeout-的一些注意事项" class="header-anchor">#</a> 使用 setTimeout 的一些注意事项</h2> <p>现在你应该知道在浏览器内部定时器是如何工作的了。不过在使用定时器的过程中，如果你不了解定时器的一些细节，那么很有可能掉进定时器的一些陷阱里。所以接下来，我们就来讲解一下在使用定时器过程中存在的那些陷阱。</p> <p><strong>1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行</strong></p> <p>在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。我们先看下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span><span class="token operator">+</span><span class="token number">8</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。</p> <p>通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。</p> <p>你也可以打开 Performance 来看看其执行过程，如下图所示：</p> <p><img src="https://blog.poetries.top/img/static/gitee/2019/11/33.png" alt=""></p> <p>从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。</p> <p><strong>2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒</strong></p> <p>也就是说在定时器函数里面嵌套调用定时器，也会延长定时器的执行时间，可以先看下面的这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>cb<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上述这段代码你有没有看出存在什么问题？</p> <p>你还是可以通过 Performance 来记录下这段代码的执行过程，如下图所示</p> <p><img src="https://blog.poetries.top/img/static/gitee/2019/11/34.png" alt=""></p> <p>上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是Chromium 实现 4 毫秒延迟的代码，你可以看下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> kMaxTimerNestingLevel <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
 
<span class="token comment">// Chromium uses a minimum timer interval of 4ms. We'd like to go</span>
<span class="token comment">// lower; however, there are poorly coded websites out there which do</span>
<span class="token comment">// create CPU-spinning loops.  Using 4ms prevents the CPU from</span>
<span class="token comment">// spinning too busily and provides a balance between CPU spinning and</span>
<span class="token comment">// the smallest possible interval timer.</span>
<span class="token keyword">static</span> constexpr base<span class="token operator">::</span>TimeDelta kMinimumInterval <span class="token operator">=</span> base<span class="token operator">::</span>TimeDelta<span class="token operator">::</span><span class="token function">FromMilliseconds</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>base::TimeDelta interval_milliseconds =
      std::max(base::TimeDelta::FromMilliseconds(1), interval);
 
  if (interval_milliseconds &lt; kMinimumInterval &amp;&amp;
      nesting_level_ &gt;= kMaxTimerNestingLevel)
    interval_milliseconds = kMinimumInterval;
 
  if (single_shot)
    StartOneShot(interval_milliseconds, FROM_HERE);
  else
    StartRepeating(interval_milliseconds, FROM_HERE);
</code></pre></div><p>所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如你用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。</p> <p><strong>3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒</strong></p> <p>除了前面的 4 毫秒延迟，还有一个很容易被忽略的地方，那就是未被激活的页面中定时器最小值大于 1000 毫秒，也就是说，如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点你在使用定时器的时候要注意。</p> <p><strong>4. 延时执行时间有最大值</strong></p> <p>除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，这导致定时器会被立即执行。你可以运行下面这段代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot; 极客时间 &quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> timerID <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>showName<span class="token punctuation">,</span><span class="token number">2147483648</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 会被理解调用执行</span>
</code></pre></div><p>运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。</p> <p><strong>5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉</strong></p> <p>如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。这点在前面介绍 this 的时候也提过，你可以看下面这段代码的执行结果：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> name<span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> MyObj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
  <span class="token function-variable function">showName</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span>showName<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。</p> <p>那么该怎么解决这个问题呢？通常可以使用下面这两种方法。</p> <p>第一种是将MyObj.showName放在匿名函数中执行，如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 箭头函数</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 或者 function 函数</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><p>第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>MyObj<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ul><li>首先，为了支持定时器的实现，浏览器增加了延时队列。</li> <li>其次，由于消息队列排队和一些系统级别的限制，通过 setTimeout 设置的回调任务并非总是可以实时地被执行，这样就不能满足一些实时性要求较高的需求了。</li> <li>最后，在定时器中使用过程中，还存在一些陷阱，需要你多加注意。</li></ul> <p>通过分析和讲解，你会发现函数 setTimeout 在时效性上面有很多先天的不足，所以对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/retech-fe/browser-working-principle/edit/main/docs/guide/part4/lesson16.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">2023/2/9 14:31:46</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/browser-working-principle/guide/part4/lesson15.html" class="prev">
        消息队列和事件循环：页面是怎么活起来的
      </a></span> <span class="next"><a href="/browser-working-principle/guide/part4/lesson17.html">
        Webapi：XMLHttpRequest是怎么实现的
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/browser-working-principle/assets/js/app.f3d4122f.js" defer></script><script src="/browser-working-principle/assets/js/3.a46f6e33.js" defer></script><script src="/browser-working-principle/assets/js/31.029dd5e9.js" defer></script><script src="/browser-working-principle/assets/js/6.7e6898f0.js" defer></script>
  </body>
</html>
